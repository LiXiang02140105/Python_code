'''
用filter求素数
    计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：
    首先，列出从2开始的所有自然数，构造一个序列：
    2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
    取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：
    3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
    取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
    5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
    取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
    不断筛下去，就可以得到所有的素数。
'''

def _odd_iter():
    '''
        用Python来实现这个算法，可以先构造一个从3开始的奇数序列：
        使用 yield 来生成了一个generator对象，返回的这个 it/n 的序列，是一个惰性序列
            即每一次使用next(it)才能够取到下一个元素
    '''
    n =  1
    while True:
        n = n + 2    
        yield n
def _not_divisible(n):
    '''
        筛选留下不能够被整除的
            因为，能够被整除的，都是传入的n的倍数，而x是来自于 
    '''
    return lambda x : x % n > 0


def primes():
    '''
        这是一个筛选器 filter
        1、利用 _odd_iter()生成由3开始的奇数序列  
            --->> 利用生成器yield生成的，惰性序列
        2、再通过_not_divisible()对获取的每一个 奇数，筛选(去除)其在惰性序列中的倍数
    '''
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列


if __name__ == "__main__":
    for i in primes():
        if i < 1000:
            print(i)
        else:
            break